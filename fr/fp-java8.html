<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Functional programming for the working Javaist (FR)</title>

		<meta name="description" content="Présentation de la programmation fonctionnelle pour les développeurs Java">
		<meta name="author" content="Andrea Cesaro">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="../css/reset.css">
		<link rel="stylesheet" href="../css/reveal.css">
		<link rel="stylesheet" href="../css/theme/sky.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="../lib/css/monokai.css">

		<style>
			* {
  				box-sizing: border-box;
			}

			/* Create two equal columns that floats next to each other */
			.column {
  				float: left;
  				width: 50%;
  				padding: 10px;
			}

			/* Clear floats after the columns */
			.row:after {
  				content: "";
  				display: table;
  				clear: both;
			}
		</style>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Functional programming for the working Javaist</h2>
					<h5>Motivations à la programmation fonctionnelle en Java8+</h5>
					<p>
						<small>Auteur <a href="http://cexj.github.io">Andrea Cesaro</a>, powered by: <a href="https://github.com/hakimel/reveal.js/">Reveal.js</a></small>
					</p>
				</section>

				<section>
					<h3>Résumé de la presentation</h3>
					<ul>
						<li class="fragment fade-right">Qu'est-ce que la PF ?</li>
						<li class="fragment fade-right">Pourquoi la PF ?</li>
						<li class="fragment fade-right">... et pourquoi maintenant ?</li>
						<li class="fragment fade-right">Où est Java dans tu ça ?</li>
						<li class="fragment fade-right">Quoi apprendre ?</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>Qu'est-ce que la programmation fonctionnelle ?</h2>
					</section>					
					<section>
						<h3>Un peu d'histoire</h3>		
						<ul>
							<li class="fragment fade-right">(&sim;1930) <b>Alonzo Church</b> introduit le <b>&lambda;-Calculus</b></li>
							<li class="fragment fade-right">(&sim;1930) <b>Alan Turing</b> introduit la <b>Machine de Turing</b></li>
							<li class="fragment fade-right">(&sim;1936) <b>Alonzo Church</b> et <b>Alan Turing</b> prouvent l'équivalence des deux théories</li>
							<li class="fragment fade-right">(&sim;1940) <b>John von Neumann</b> introduit l'<b>architecture</b> des moderne ordinateurs</li>
						</ul>		
					</section>
					<section>
						<h3>Les paradigmes de programmation</h3>
						<div class="row">
  							<div class="column">
    							<b class="fragment fade-right">Imperative</b>
    							</div>
  							<div class="column">
    							<b class="fragment fade-left">Declarative</b>
    						</div>
						</div>
						<div class="row">
  							<div class="column">
    							<div class="fragment fade-right">
									<ul>									
										<li>Procédurale</li>
										<li>Structurée</li>
										<li>Orientée objet*</li>
									</ul>
								</div>
  							</div>
  							<div class="column">
    							<div class="fragment fade-left">
									<ul>									
										<li>Logique</li>
										<li>Fonctionnelle</li>
									</ul>
								</div>
  							</div>
						</div>
						<p class="fragment fade-right">
							<small>							
								La programmation <b>impérative</b> descend de la <b>machine de Turing</b>, alors que la programmation <b>fonctionnelle</b> à partir du <b>&lambda;-Calculus</b>
							</small>						
						</p>
					</section>

					<section>
						<h3>On peut decrire un paradigme en fonction de comment il organise le code et de sont objectif.</h3>		
					</section>
					<section>	
						<p>Pour exemple la programmation <b>orientée objet</b></p>
						<ul>
							<li class="fragment fade-right">Organise le code en objects (donnés + méthodes)</li>
							<li class="fragment fade-right">Cacher l'implémentation et encapsuler l'état dans des objets</li>
						</ul>		
					</section>
					<section>	
						<p>La programmation <b>functionelle</b></p>
						<ul>
							<li class="fragment fade-right">Organise le code en functions</li>
							<li class="fragment fade-right">Séparer le code pure (sans état) du code impure (avec état)</li>
						</ul>
						<p class="fragment fade-right">La programmation <b>functionelle</b> "pure"</p>
						<ul>
							<li class="fragment fade-right">Organise le code en functions</li>
							<li class="fragment fade-right">Virtuellement éliminer le code impure</li>
						</ul>		
					</section>
					<section>	
						<p>Les actions impures sont :</p>
						<ul>
							<li class="fragment fade-right">Lire d'une source externe (fichiers, base de donnes, internet...)</li>
							<li class="fragment fade-right">Écrire sur une ressource externe (logs, fichiers, base de donnes, internet...)</li>
							<li class="fragment fade-right">Muter le valeur d'une variable</li>
						</ul>		
					</section>
				</section>
				<section>	
					<section>
						<h2>Pourquoi la programmation fonctionnelle ?</h2>
					</section>	
					<section>
						<h3>La programmation concurrente/parallèle/distribuée est plus facile</h3>
						<p class="fragment fade-right">
							Sans états mutables, pas besoin de blocs de synchronisation et les fonctions pures sont bien adaptées pour décrire des tâches à exécuter en parallèle.						
						</p>
					</section>
					<section>
						<h3>La transparence référentielle simplifie le raisonnement sur le code</h3>
						<small class="fragment fade-right">	
							<q cite="https://fr.wikipedia.org/wiki/Transparence_r%C3%A9f%C3%A9rentielle">La transparence référentielle est une propriété des expressions d'un langage de programmation qui fait qu'une expression peut être remplacée par sa valeur sans changer le comportement du programme</q>
						</small>
					</section>	
					<section>
						<h3>Example</h3>
							<pre class="fragment fade-right"><code data-trim data-line-numbers>Integer x1 = reference.getX(param);
Integer x2 = reference.getX(param);
Integer sum =  x1 + x2;	
							</code></pre>
							<pre class="fragment fade-right"><code class="hljs" data-trim data-line-numbers>Integer sum = 2*reference.getX(param);</code></pre>
					</section>
					<section>
						<h3>Le code pure est plus facil à tester</h3>
						<p class="fragment fade-right">
							Sans dépendances externes et états mutables, pas besoin des mocks et les tests sont plus fiables.
						</p>	
					</section>
					<section>
						<h3>Si statiquement et fortement typé, le code est plus expressive plus facil à lire et avec mois des bugs</h3>
						<p class="fragment fade-right">
							Dans un language fonctionnelle statiquement et fortement typé, un peut exprimer les contraintes directement dans les types.
						</p>
					</section>	
					<section>
						<h3>Example</h3>
							<pre class="fragment fade-right"><code class="hljs" data-trim data-line-numbers>Integer maxCopiesInEn(List&lt;Book&gt; books){
  Integer res = null;
  for(Book book : books) {
    if("en".equals(book.getLanguage())) {
      Integer bookNumCopies = book.getNumCopies()
      if(res == null || res &lt; bookNumCopies) {
        res = bookNumCopies;
      } 
    }
  }
  if(res == null) {
    throw new RuntimeException();	
  } else {
    return res;
  } 
}
							</code></pre>
					</section>
					<section>
						<p>En programmation fonctionnelle</p>
						<pre><code class="hljs" data-trim data-line-numbers>Optional&lt;Integer&gt; maxCopiesInEn(List&lt;Book&gt; books){
  return books.stream()
           .filter(book -> "en".equals(book.getLanguage()))
           .map(Book::getNumCopies)
           .min((x,y) -> x &lt; y);
}</code></pre>
					</section>	
				</section>
				
				<section>	
					<section>
						<h2>... et pourquoi maintenant ?</h2>
						<small class="fragment fade-right">							
							Si c'est si bon pourquoi on ne l'a pas utilisé avant ?
						</small>
					</section>	
					<section>
						<ul>
							<li>Il faut utiliser un Garbage Collector</li>
							<li class="fragment fade-right">Pour avoir de bonnes performances il faut avoir un bon compilateur/interpreteur</li>
							<li class="fragment fade-right">Ça brille avec une complexité et une abstraction plus élevées</li>
							<li class="fragment fade-right">Ça brille dans la programmation concurrente/parallèle/distribuée</li>
							<li class="fragment fade-right">C'est plus difficile d'écrire</li>
						</ul>
					</section>	
					<section>
						<h3>Aucune de ces raisons n'est plus valable aujourd'hui</h3>
					</section>	
				</section>
				<section>
					<section>
						<h2>Où est Java dans tu ça ?</h2>			
					</section>
					<section>
						<h3>Support d'un paradigme</h3>			
						<ul>
							<li class="fragment fade-right">Niveau : semantique</li>
							<li class="fragment fade-right">Niveau : syntactique</li>
							<li class="fragment fade-right">Niveau : libraries standard</li>
						</ul>
					</section>
					<section>
						<h3>Aucun support</h3>			
						<ul class="fragment fade-right">
							<li>C</li>
							<li>COBOL</li>
							<li>FORTRANT</li>
							<li>Assembler</li>
							<li>Pascal</li>
							<li>Go</li>
						</ul>
						<p class="fragment fade-right"><small>Le style fonctionnel ne doit pas être utilisé dans ces languages</small></p>
					</section>		
					<section>
						<h3>Support secondaire</h3>			
						<ul class="fragment fade-right">
							<li>C++</li>
							<li>Java</li>
							<li>C#</li>
							<li>Smalltalk</li>
							<li>Javascript</li>
							<li>Python</li>
							<li>PHP</li>
							<li>Perl</li>
							<li>Ruby</li>
						</ul>
						<p class="fragment fade-right"><small>Le style fonctionnel peut être utilisé, mais ce n'est pas "first class citizen"</small></p>
					</section>
					<section>
						<h3>Support complet</h3>			
						<ul class="fragment fade-right">
							<li>Kotlin*</li>
							<li>Scala</li>
							<li>F#</li>
							<li>LISP (Scheme, Racket, Clojure...)</li>
							<li>ML (OCaml, ReasonMl...)</li>
							<li>ERLANG</li>
							<li>Elixir</li>
						</ul>
						<p class="fragment fade-right"><small>Le style fonctionnel est pleinement supporté, il est possible de programmer en style purement fonctionnel</small></p>
					</section>	
					<section>
						<h3>Support exclusif</h3>			
						<ul class="fragment fade-right">
							<li><i>Elm</i></li>
							<li>Haskell</li>
						</ul>
						<p class="fragment fade-right"><small>Le style purement fonctionnel est le seul disponible</small></p>
					</section>	
					<section>
						<h3>Total functional programming/Strong functional programming</h3>			
						<ul class="fragment fade-right">
							<li>Cocq</li>
							<li>Idris</li>
							<li>Agda</li>
						</ul>
						<p class="fragment fade-right"><small>Ce ne sont pas des langages Turing complet</small></p>
					</section>		
				</section>
				<section>
					<section>
						<h2>Quoi apprendre ?</h2>
					</section>	
					<section>
						<ul>
							<li><b>Pure</b> vs <b>Impure</b></li>
							<li class="fragment fade-right"><b>Immutabilité</b> vs <b>mutabilité</b></li>
							<li class="fragment fade-right"><b>Expressions-&lambda;</b> vs <b>objets anonymes</b></li>
							<li class="fragment fade-right"><b>Appel par nom</b> vs <b>initialisation lazy</b> vs <b>appeler par valeur</b></li>
							<li class="fragment fade-right"><b>API Optional</b></li>
							<li class="fragment fade-right"><b>API Stream</b></li>
							<li class="fragment fade-right"><b>API Either, Try, Functional Collections, Functional Future...</b></li>
						</ul>
					</section>
					<section>
						<h3>Plus loin</h3>
						<ul>
							<li class="fragment fade-right"><b>Recursive</b> vs <b>Tail Recursive</b> vs <b>Iterative</b></li>
							<li class="fragment fade-right"><b>Pattern matching</b></li>
							<li class="fragment fade-right"><b>Algebraic data types</b></li>
							<li class="fragment fade-right"><b>Category theory</b></li>
						</ul>
					</section>
				</section>
				
			</div>

		</div>

		<script src="../js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: '../plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../plugin/highlight/highlight.js', async: true },
					{ src: '../plugin/search/search.js', async: true },
					{ src: '../plugin/zoom-js/zoom.js', async: true },
					{ src: '../plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
